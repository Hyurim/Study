좋은 코드는 가독성이 좋은 코드다.

14. [let, const 키워드와 블록 레벨 스코프](#let-const-키워드와-블록-레벨-스코프)
15. [프로퍼티 어트리뷰트](#프로퍼티-어트리뷰트)
16. [생성자 함수에 의한 객체 생성](#생성자-함수에-의한-객체-생성)
17. [함수와 일급 객체](#함수와-일급-객체)

## let, const 키워드와 블록 레벨 스코프

### var 키워드로 선언한 변수의 문제점

1. 중복 선언이 가능함.

- 의도하지 않게 코드 블록 내에서 선언해도 모두 전역 변수가 됨.

2. 함수의 코드 블록만을 지역 스코프로 인정함.

- 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.
- 의도치 않게 전역 변수가 중복 선언되는 경우가 발생함.

3. 변수호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작함.

- 변수 호이스팅에 의해 변수 선언문 이전에 참조할 수 있다.(할당문 전에 참조하면 undefined를 반환함.)

### let 키워드

1. 이름이 같은 변수를 중복 선언하면 문법 에러가 발생함.
2. 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.
3. 변수 호이스팅이 발생하지 않는 것처럼 동작함.

- let 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행됨.
- 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행됨.
  (스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없다. (=일시적 사각지대))

4. let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.
   (let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 됨.)

### const 키워드

const 키워드는 상수를 선언하기 위해 사용.
(상수 : 재할당이 금지된 변수)

1. 대부분 let 키워드와 동일함.
2. 반드시 선언과 동시에 초기화 해야 함.
3. 재할당이 금지됨.
4. 원시 값을 할당한 경우 원시 값은 변경할 수 없는 값. (할당된 값을 변경할 수 있는 방법은 없다.)
   (상수의 이름은 대문자로 선언해서 상수를 명확히 나타내며 스네이크 케이스로 표현하는 것이 일반적임.)
5. 객체를 할당한 경우 값을 변경할 수 있다.

- 재할당을 금지할 뿐 "불변"을 의미하지 않음. (새로운 값을 재할당하는 것은 불가능하지만 프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체를 변경하는 것은 가능.)

### 총 정리

1. ES6를 사용한다면 var 키워드는 사용하지 않음.
2. 재할당이 필요한 경우 한정해 let 키워드를 사용한다. (이때 변수의 스코프는 최대한 좁게 만든다.)
3. 재할당이 필요없는 상수와 객체에는 const 키워드를 사용한다.

- 변수 선언할 때 const를 사용한 후 재할당이 필요하다면 그때 let으로 변경해도 늦지 않다.

## 프로퍼티 어트리뷰트

### 내부 슬롯과 내부 메서드

자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 "의사 프로퍼티"와 "의사 메서드"이다.
이중 대괄호로 감싼 이름들이 내부 슬롯과 내부 메서드이다.

실제로 동작하지만 개발자가 직접 접근할 수 있도록 외부에 공개된 객체의 프로퍼티는 아님.
(내부 슬롯과 내부 메서드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않음.)

### 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의함.
(프로퍼티 상태 : 프로퍼티의 값, 값의 갱신 가능 여부, 열거 가능 여부)

프로퍼티 어트리뷰트 : 자바스크립트 엔진이 관리하는 내부 상태 값
내부 슬롯

Object.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로 확인할 수는 있다.

const person = { </br>
name: 'Lim' </br>
}; </br>
</br>
console.log(Object.getOwnPropertyDescriptor(person, 'name'));</br>

첫 번째 매개변수로 객체의 참조를 전달하고, 두 번째 매개변수로 프로퍼티 키를 문자열로 전달함.

Object.getOwnPropertyDescriptor 메서드는 프로퍼티 어트리뷰트 정보를 제공하는 "프로퍼티 디스크립터 객체"를 반환한다.
(존재하지않거나 상속받은 것에 대해 요구할 경우 undefined가 반환됨.)
하나의 프로퍼티에 대해 프로퍼티 디스크립터 객체를 반환함.

ES8에서 도입된 Object.getOwnPropertyDescriptors 메서드는 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환함.

### 데이터 프로퍼티와 접근자 프로퍼티

1. 데이터 프로퍼티

- 키와 값으로 구성된 일반적인 프로퍼티. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티다.

1-1. [[Value]]

- 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값
- 값을 변경하면 [[Value]]에 값을 재할당함. 없을 경우 동적 생성하고 생성된 [[Value]]에 값을 저장함.
- 생략했을 때 기본값 undefined

1-2. [[Writable]]

- 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖음.
- 해당 값이 false인 경우 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 됨.
- 생략했을 때 기본값 false

1-3. [[Enumerable]]

- 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖음.
- 해당 값이 false인 경우 해당 프로퍼티는 for... in문이나 Object.keys 메서드 등으로 열거할 수 없음.
- 생략했을 때 기본값 false

1-4. [[Configurable]]

- 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 가짐.
- 해당 값이 false인 경우 프로퍼티 삭제, 어트리뷰트 값의 변경이 금지됨.
  (단, [[Writable]]가 true인 경우 [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용됨.)
- 생략했을 때 기본값 false

2. 접근자 프로퍼티
   자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티.

2-1. [[Get]]

- 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수.
  (접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환됨.)
- 생략했을 때 기본값 undefined
  2-2. [[Set]]

- 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수.
  (접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값, 즉 setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장됨.)
- 생략했을 때 기본값 undefined
  2-3.[[Enumerable]]

- 데이터 프로퍼티와 동일

2-4. [[Configurable]]

- 데이터 프로퍼티와 동일

const person = { </br>
// 데이터 프로퍼티 </br>
firstName: 'Ungmo', </br>
lastName: 'Lim', </br>
</br>
//fullName은 접근자 함수로 구성된 접근자 프로퍼티 </br>
</br>
//getter 함수 </br>
get fullName() { </br>
return `${this.firstName} ${this.lastName}`; </br>
}, </br>
//setter 함수 </br>
set fullName(name) { </br>
[this.firstName, this.lastName] = name.split(' '); </br>
} </br>
}; </br>
</br>
// 데이터 프로퍼티를 통한 프로퍼티 값의 참조 </br>
console.log(person.firstName + ' ' + person.lastName); </br>
</br>
// 접근자 프로퍼티를 통한 프로퍼티 값의 저장 </br>
// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출됨. </br>
person.fullName = 'JongHyeon Lim'; </br>
console.log(person); </br>
</br>
// 접근자 프로퍼티를 통한 프로퍼티 값의 참조 </br>
// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출됨. </br>
console.log(person.fullName); </br>
</br>
// firstName은 데이터 프로퍼티 </br>
// 데이터 프로퍼티는 [[Value]], [[Writable]], [[Enumerable]], [[Configurable]] </br>
// 프로퍼티 어트리뷰트를 갖음. </br>
</br>
let descriptor = Object.getOwnPropertyDescriptor(person, 'firstName'); </br>
console.log(descriptor); </br>
</br>
// fullName은 접근자 프로퍼티 </br>
// 접근자 프로퍼티는 [[Get]], [[Set]], [[Enumerable]], [[Configurable]] </br>
// 프로퍼티 어트리뷰트를 갖음. </br>
</br>
descriptor = Object.getOwnPropertyDescriptor(person, 'fullName'); </br>
console.log(descriptor); </br>

내부 슬롯/메서드 관점에서 설명하면

1. 프로퍼티 키가 유효한지 확인함.

- 프로퍼티 키는 문자열 또는 심벌이어야 함. 프로퍼티 키 "fullName"은 문자열이므로 유효한 프로퍼티 키다.

2. 프로토타입 체인에서 프로퍼티를 검색함.

- person 객체에 fullName 프로퍼티가 존재함.

3. 검색된 fullName 프로퍼티가 데이터 데이터 프로퍼티인지 접근자 프로퍼티인지 확인함.

- fullName 프로퍼티는 접근자 프로퍼티임.

4. 접근자 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수를 호출하여 그 결과를 반환함.

- 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값은 Object.getOwnPropertyDescriptor 메서드가 반환하는 프로퍼티 디스크립터 객체의 get 프로퍼티 값과 같음.

### 프로퍼티 정의

새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의 하는것.

Object.defineProperty 메서드를 사용하면 프로퍼티의 어트리뷰트를 정의할 수 있음.

- 디스크립터 객체의 프로퍼티를 누락시키면 undefined, false가 기본값.

### 객체 변경 방지

객체의 변경을 방지하는 다양한 메서드를 제공함.

1. Object.preventExtensions 메서드

- 객체의 확장을 금지함. (프로퍼티 추가가 금지됨.)
- 가능 여부는 Object.isExtensible 메서드로 확인 가능

2. Object.seal 메서드

- 객체를 밀봉함. (읽기와 쓰기만 가능(프로퍼티 추가 및 삭제, 프로퍼티 어트리뷰트 재정의의 금지를 의미함.))
- Object.isSealed 메서드로 확인 가능

3. Object.freeze 메서드

- 객체 동결 (읽기만 가능(프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지))
- Object.isFrozen 메서드로 확인 가능

#### 불변 객체

- 변경 방지 메서드들은 얕은 변경 방지로 직속 프로퍼티 변경만 방지되고 중첩 객체까지는 영향을 주지 않음.
- 중첩 객체까지 동결하려면 모든 프로퍼티에 대해 Object.freeze 메서드를 재귀적으로 호출해야 함.

## 생성자 함수에 의한 객체 생성

### Object 생성자 함수

- new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환함.
  (빈 객체를 생성한 이후 프로퍼티 또는 메서드를 추가하여 객체를 완성할 수 있음.)
  생성자 함수 : new 연산자와 함께 호출하여 객체를 생성하는 함수.
  인스턴스 : 생성자 함수에 의해 생성된 객체

(Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp.Promise 등의 빌트인 생성자 함수를 제공함.)

### 생성자 함수

- 동일한 프로퍼티를 갖는 객체를 여러개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적임.
  (객체는 프로퍼티를 통해 객체 고유의 상태를 표현함. (객체마다 프로퍼티 값은 다를 수도 있지만 메서드는 내용이 동일한 경우가 일반적임.))

- 생성자 함수에 의한 객체 생성 방식은 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있음.

일반 함수와 동일한 방법으로 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작하고, 그게 아니라면 일반 함수로 동작한다.

#### 인스턴스 생성 과정

생성자 함수 역할

인스턴스 생성(필수)한 후 인스턴스 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)(옵션)
이후 암묵적으로 인스턴스를 반환함.

1. 인스턴스 생성과 this 바인딩

- 인스턴스는 this에 바인딩된다.
  (바인딩 : 식별자와 값을 연결하는 과정)

2. 인스턴스 초기화

- this에 바인딩되어 있는 인스턴스에 프로퍼티나 메서드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 프로퍼티에 할당하여 초기화하거나 고정값을 할당함.(개발자가 기술)

3. 인스턴스 반환

- 생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환됨.(this가 아닌 다른 객체를 명시적으로 반환하면 return 문에 명시한 객체가 반환됨.)
  원시 값을 반환하면 원시 값 반환은 무시되고 this가 반환.
  (this가 아닌 다른 값을 반환하는 것은 기본 동작읠 훼손함. 따라서, 반드시 return문을 생략해야 함.)

#### 내부 메서드 Call과 Construct

함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수와 생성자 함수로서 호출할 수 있음.
함수는 일반 객체와 동일하게 동작 가능. (내부 슬롯 / 메서드 모두 보유)

```
// 함수는 객체다.
function foo() {}

// 함수는 프로퍼티를 소유할 수 있다.
foo.prop = 10;

// 메서드도 소유할 수 있음.
foo.method = function () {
  console.log(this.prop);
};

foo.method();

```

일반 객체는 호출할 수 없지만 함수는 호출할 수 있음.
함수 객체 만을 위한 내부 슬롯과 메서드를 추가로 가지고 있음.

일반 함수로서 호출 - [[Call]]이 호출
new 연산자 + 생성자 함수 호출 - [[Construct]]가 호출

#### constructor와 non-constructor

- constructor
  함수 선언문, 함수 표현식, 클래스

- non-constructor
  메서드(ES6 메서드 축약 표현), 화살표 함수
  (new 연산자로 호출할 경우 에러가 발생함)

// Call과 Construct의 차이점은 일반 함수로서 호출과 new + 생성자 함수 호출 말고 또 뭐가 있을까

#### new 연산자

new 연산자 + 함수 호출 = 생성자 함수로 동작 (constructor이여야 한다.)
([[Construct]]가 호출됨.)

```
// 일반 함수
function add(x, y) {
  return x + y;
}

// 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출하여 생성자 함수로 동작하게 하도록 함.
let inst = new add();

// 함수가 객체를 반환하지 않았으므로 반환문 무시. 따라서 빈 객체가 생성되어 반환.
console.log(inst); {}

//객체에 반환하는 일반 함수
function createUser(name, role) {
  return { name, role };
}

// 일반 함수를 new 연산자와 함께 호출
inst = new createUser('Yim', 'admin');

// 함수가 생성한 객체를 반환
console.log(inst);
```

new 연산자 없이 호출하면 일반 함수로 [[Call]]이 호출됨.

생성자 함수와 일반 함수는 특별한 형식적 차이가 없다.
따라서, 생성자 함수는 일반적으로 파스칼 케이스로 명명하여 구별할 수 있도록 하는 것이 좋다.

#### new.target

함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로서 호출 되었는지 확인 할 수 있음.
생성자 함수로서 호출 : 함수 내부의 new.target은 함수 자신을 가리킴.
일반 함수로서 호출 : undefined가 출력됨.

## 함수와 일급 객체

- 일급 객체

1. 무명의 리터럴로 생성할 수 있다. (즉, 런타임에 생성이 가능함.)
2. 변수나 자료구조에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있음.
4. 함수의 반환값으로 사용할 수 있음.

함수 객체는 호출할 수 있으며, 함수 고유의 프로퍼티를 소유함.

```
// 무명의 리터럴로 생성할 수 있고, 변수에 저장할 수 있다.
// 런타임에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당됨.
const increase = function (num) {
  return ++num;
}

const decrease = function (num) {
  return --num;
};

// 객체에 저장 가능.
const auxs = { increase, decrease };

// 함수의 매개변수에 전달 가능하며, 반환 값으로 사용할 수 있음.
function makeCounter(aux) {
  let num = 0;

  return function () {
    num = aux(num);
    return num;
  };
}

const a = makeCounter(auxs.increase);
console.log(a()); // 1
console.log(a()); // 2

const b = makeCounter(auxs.decrease);
console.log(b()); // -1
console.log(b()); // -2

```

함수는 객체와 동일하게 사용할 수 있다.
값을 사용할 수 있는 곳이라면 어디서든지 리터럴로 정의할 수 있으며, 런타임에 함수 객체로 평가 됨.

### 함수 객체의 프로퍼티

함수도 프로퍼티를 가질 수 있음.

1. arguments 프로퍼티

함수 객체의 arguments 프로퍼티 값은 arguments 객체다.
(argument 객체 : 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한 `유사 배열 객체`, 함수 내부에서 지역 변수처럼 사용됨.)
<- 함수 외부에서는 참조 불가능

유사 배열 객체 : length 프로퍼티를 가진 객체로 for 문으로 순회할 수 있는 객체
(배열 메서드를 사용할 경우 에러가 발생함.)

이전에 설명했던 내용 중에서 자바스크립트는 함수의 매개변수와 인수의 개수가 일치하는지 확인하지 않는데 부족할 경우에는 undefined로 유지하지만 그냥 버려지지 않는다.
arguments 객체의 프로퍼티로 보관된다.

매개변수 개수를 확정할 수 없는 가변인자 함수를 구현할 때 유용함.

2. length 프로퍼티

함수를 정의할 때 선언한 매개변수의 개수를 가리킴.

arguments 객체 : 인자의 개수
함수 객체 : 매개변수의 개수

3. name 프로퍼티

함수 객체 : 함수 이름을 나타냄
함수 객체를 가리키는 식별자를 값으로 가짐.

4. `__proto__` 접근자 프로퍼티

[[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티

5. prototype 프로퍼티

함수가 객체를 생성하는 생성자 함수로 호출될 때 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킴.

생성자 함수로 호출할 수 있는 함수 객체. (constructor만이 소유하는 프로퍼티)
<일반 객체와 생성자 함수로 호출할 수 없는 non-constructor에는 없다.>
