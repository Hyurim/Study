> 좋은 코드는 가독성이 좋은 코드다.
> (완성도는 기본)

자바스크립트의 동작 원리를 담고 있는 핵심 개념

소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리 하는 영역.
식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘.
`모든 코드는 실행 컨텍스트를 통해 실행되고 관리 됨`

렉시컬 환경 : 식별자와 스코프
스택 : 코드 실행 순서

---

> ### 소스코드의 타입

#### 1. 전역 코드

`전역에 존재하는 소스코드`
전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않음.
`전역 변수`를 관리하기 위해 최상위 스코프인 `전역 스코프 생성`해야 함.

#### 2. 함수 코드

`함수 내부에 존재하는 소스코드 `
함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않음.
`지역 스코프 생성` 및 `지역 변수`, `매개변수`, `arguments 객체`를 관리해야 함.

#### 3. eval 코드

빌트인 전역함수 `eval` 함수에 인수로 전달되어 실행되는 소스코드
strict mode에서 자신만의 독자적인 스코프 생성

#### 4. 모듈코드

`모듈 내부에 존재하는 소스코드`
모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않음.
모듈별로 독립적인 모듈 스코프를 생성함.

>

#### 구별 이유

소스코드의 타입에 따라 실행 컨텍스트를 `생성하는 과정`과 `관리 내용`이 다르기 때문

---

> ### 소스코드의 평가와 실행

소스코드의 평가와 실행 과정으로 나누어 처리

평가 과정 : `실행 컨텍스트 생성` -> `선언문 먼저 실행` -> `실행 컨텍스트가 관리하는 스코프에 등록`
-> `소스코드 순차적 실행`

```
var x;
x = 1;
```

평가 과정 : `선언문 var x;`를 먼저 실행. (실행 컨텍스트가 관리하는 스코프에 등록 `undefined`로 초기화)
실행 과정 : `할당문 x=1;`만 실행

---

>

### 실행 컨텍스트의 역할

```
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
// 지역 변수 선언
const x = 10;
const y = 20;

// 메서드 호출
console.log(a + x + y);; // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

#### 1. 전역 코드 평가

`전역 코드 평가 과정을 거치며 실행하기 위한 준비`
선언문만 먼저 실행 -> 전역 변수와 전역 함수가 전역 스코프에 등록
`var 키워드`로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 `전역 객체의 프로퍼티와 메서드`가 됨.

#### 2. 전역 코드 실행

전역 코드가 순차적으로 실행 -> 변수에 값 할당 및 함수 호출
`함수가 호출되면 전역 코드의 실행을 중단하고 실행 순서를 변경하여 함수 내부로 진입`

#### 3. 함수 코드 평가

함수 코드 평가 과정을 거치며 함수 코드를 실행하기 위한 준비
`매개변수, 지역 변수 선언문 먼저 실행 -> 지역 스코프에 등록(this 바인딩도 결정됨)`

#### 4. 함수 코드 실행

매개 변수와 지역 변수에 값이 할당.
console.log 메서드가 호출

> 1. `console.log` 메서드를 호출하려면 먼저 `console`을 `스코프 체인`을 통해 검색한다.
>    (함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 함. 하지만 `console` 식별자는 스코프 체인에 등록되어 있지 않고 전역 객체에 프로퍼티로 존재. <- 전역 객체의 프로퍼티가 마치 전역 변수처럼 전역 스코프를 통해 검색 가능해야 한다는 것을 의미함.)
> 2. `log` 프로퍼티를 `console` 객체의 프로토 타입 체인을 통해 검색
> 3. `console.log` 메서드에 인수로 전달된 표현식 평가 (식별자는 스코프 체인을 통해 검색)
> 4. 실행 종료 후 코드 실행 과정이 종료되고 전역 코드 실행을 계속 진행

`코드가 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요`

---

>

### 실행 컨텍스트 스택

![](https://velog.velcdn.com/images/hyuri/post/96c7901c-1478-4d4c-ae0b-4dd0aad79478/image.png)

코드의 실행 순서를 관리함.
소스코드가 평가되면 실행 컨텍스트가 생성되고 실행 컨텍스트 스택의 최상위에 쌓임.
최상위에 존재하는 실행 컨텍스트는 언제나 `현재 실행 중인 코드의 실행 컨텍스트`다.

---

>

### 렉시컬 환경

식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트
`스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할`

![](https://velog.velcdn.com/images/hyuri/post/0a217687-57ba-421c-897e-03ed6933e8e0/image.png)

실행 컨텍스트는 `LexicalEnvironment` ,`VariableEnvironment` 컴포넌트로 구성

생성 초기에는 하나의 동일한 렉시컬 환경을 참조
(몇 가지 상황을 만나면 각 컴포넌트의 내용이 달라지는 경우도 있음)

---

>

### 실행 컨텍스트의 생성과 식별자 검색 과정

```
var x = 1;
const y =2;
function foo (a) {
var x = 3;
const y = 4;

function bar (b){
const z = 5;
console.log(a + b + x + y + z);
}
bar(10);
}

foo(20); // 42
```

<br>

#### 1. 전역 객체 생성

전역 코드가 평가되기 이전에 생성.
(`빌트인 전역 프로퍼티, 함수`, `표준 빌트인 객체` 추가, 동작환경에 따라 `클라이언트 사이드 Web API`, 특정 환경을 위한 `호스트 객체`를 포함.)
(`Object.prototype`을 상속 받음. <- 프로토타입 체인의 일원)

#### 2. 전역 코드 평가

>

1. 전역 실행 컨텍스트 생성
2. 전역 렉시컬 환경 생성
   2-1. 전역 환경 레코드 생성
   2-1-1. 객체 환경 레코드 생성
   2-1-2. 선언적 환경 레코드 생성
   2-2. this 바인딩
   2-3. 외부 렉시컬 환경에 대한 참조 결정
   ![](https://velog.velcdn.com/images/hyuri/post/7ba73000-f62d-4ab2-85a0-23d249dd2c24/image.png)

#### 1. 실행 컨텍스트 생성

`Global Execution Context`
비어있는 전역 실행 컨텍스트를 생성하여 스택에 푸시. <- 스택의 최상위, 실행 중인 실행 컨텍스트가 됨.

#### 2. 전역 렉시컬 환경 생성

`Global Execution Context` -> `Global Lexical Environment`

#### 2-1. 전역 환경 레코드 생성

전역 환경 레코드는 전역 변수를 관리하는 `전역 스코프`, 전역 객체의 `빌트인 전역 프로퍼티, 전역 함수`, `표준 빌트인 객체`를 제공

`var`와 `let, const` 키워드로 선언한 전역 변수를 구분하기 위해 `객체 환경 레코드`와 `선언적 환경 레코드`로 구성
(서로 협력하여 전역 스코프와 전역 객체를 관리)

`객체 환경 레코드` : `var`로 선언한 전역 변수, 함수 선언문으로 정의한 전역 함수, 빌트인 전역 프로퍼티와 전역함수, 표준 빌트인 객체를 관리
`선언적 환경 레코드` : `let, const`로 선언한 전역 변수 관리

#### 2-1-1. 객체 환경 레코드 생성

전역 코드 평가 과정에서 `var 키워드로 선언한 전역 변수`와 `함수 선언문으로 정의된 전역 함수`는 전역 환경 레코드의 객체 환경 레코드에 연결된 BindingObject를 통해 전역 객체의 `프로퍼티`와`메서드`가 됨.
`<- 객체 환경 레코드에서 식별자를 검색하면 전역 객체의 프로퍼티를 검색하여 반환`

#### 2-1-2. 선언적 환경 레코드 생성
